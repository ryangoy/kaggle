"""
Stacking and KFolds SDK
@author Ryan Goy

This code base is for non-image based Kaggle competitions. Models can
be defined in the models folder and must be imported in this file. The
stack is defined in initialize_model(). Feature engineering can be defined
in the feature_engineering folder and must also be imported in this file. 
You must call the functions in generate_data(). The rest should be 
generalized minus a few hard-coded things.

A few things to note:
-Indexing is assumed to be conserved. If a method shuffles the data,
it returns predictions in the original order.
-Many things are still hard coded at this point. There are some features
that are in here specific to the Sberbank Kaggle competition. It shouldn't
be too hard to adjust, though
-At test time, predictions are generated by running the test data through
each trained fold and averaged over the number of folds at the end.
-I might add json config file support so defining everything becomes more
simple and readable.
"""

import numpy as np
import pandas as pd
from feature_engineering.preprocess import import_clean
from feature_engineering.generate_features import \
    encode_categorical_features, \
    generate_time_features,\
    generate_relative_square_footage,\
    generate_room_information
from utils.kfold import KFold
from models.naive_xgb import NaiveXGB
import time
import sys
import math

LABEL_NAME = 'price_doc'
NUM_FOLDS = 5

def generate_data():
    train, test, macro = import_clean()
    encode_categorical_features(train, test)
    generate_time_features(train, test)
    generate_relative_square_footage(train, test)
    generate_room_information(train, test)
    return train, test

def initialize_models():
    """
    All layers of models are defined here. The index of the levels
    array corresponds to the level of the stack. 

    Note: the length of the last level must be 1 (i.e. len(levels[-1]) == 1)
    """
    levels = []
    # L0 models
    models = []
    models.append(NaiveXGB())
    levels.append(models)


    return levels

def train_and_test_level(models, train, test):
    X_trn = train.drop(LABEL_NAME, 1)
    y_trn = train[LABEL_NAME]
    
    kf = KFold(X_trn, y_trn, test, num_folds=NUM_FOLDS)
    val_df = pd.DataFrame()
    test_df = pd.DataFrame()
    for model in models:
        print '\tTraining {}...'.format(model.name)
        val_df[model.name], test_df[model.name] = kf.run_kfolds_on_model(model)
    return val_df, test_df

def validate(preds, labels, loss='RMSLE'):
    assert len(preds) == len(labels)

    total = 0
    for pred, label in zip(preds, labels):
        if loss == 'RMSLE':
            total += (math.log(pred+1) - math.log(label+1))**2
        else:
            print '[ERROR] Unknown loss: {}'.format(loss)
            sys.exit(1)
    print 'Validation loss is {:.5f}'.format(total / len(preds))

def run():
    t = time.time()
    start_time = t

    # feature engineering
    print 'Importing and generating features...'
    train, test = generate_data()
    print 'Finished in {:.2f} seconds.'.format(time.time()-t)
    t = time.time()
    
    # get models ready
    print 'Initializing models...'
    levels = initialize_models()
    print 'Finished in {:.2f} seconds.'.format(time.time()-t)
    t = time.time()

    # train & test for each model
    # this is a weird approach, but it's simpler since we don't have to keep track of models
    # for test time.
    curr_train_df = train # assuming we don't need to keep track of intermediate outputs
    curr_test_df = test
    for i in range(len(levels)):
        print 'Training and testing L{} models with {} folds...'.format(i, NUM_FOLDS)
        curr_train_df, curr_test_df = train_and_test_level(levels[i], curr_train_df, curr_test_df)
        print 'Finished L{} training and testing in {:.2f} seconds.'.format(i, time.time()-t)
        t = time.time()
    
    # validation
    y_val = curr_train_df['NaiveXGB']
    validate(y_val, train[LABEL_NAME])

    # write submission file
    submission_df = pd.DataFrame()
    submission_df['id'] = test['id']
    submission_df['price_doc'] = curr_test_df.iloc[:,0]
    submission_df.to_csv('sub.csv', index=False)

    print 'Total runtime: {:.2f} seconds'.format(time.time()-start_time)

# boilerplate code
if __name__ == '__main__':
    run()
